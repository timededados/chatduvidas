// =======================================================
// CHATBOT ABRAMEDE ‚Äì Busca sem√¢ntica com m√∫ltiplas varia√ß√µes
// Busca com pergunta original + varia√ß√µes, valida com OpenAI
// =======================================================

import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import XLSX from 'xlsx';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import OpenAI from 'openai';
import { pipeline } from '@xenova/transformers';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

const DATA_DIR = path.join(__dirname, 'data');

// Modelo de embeddings (ser√° carregado na inicializa√ß√£o)
let extractor = null;

let dados = {
  indice: [],
  podcasts: [],
  aulas: [],
  paginasLivro: [],
  embeddingsLivro: [],
  sumario: '' // Sum√°rio do livro (p√°ginas 46-59)
};

function carregarDados() {
  const arquivosNecessarios = [
    'indice_pesquisa_abramede.xlsx',
    'Podcasts.xlsx',
    'Aulas.xlsx',
    'abramede_texto.json',
    'embeddings_abramede.json'
  ];

  const arquivosFaltando = arquivosNecessarios.filter(arquivo => 
    !fs.existsSync(path.join(DATA_DIR, arquivo))
  );

  if (arquivosFaltando.length > 0) {
    console.error('\n‚ùå ERRO: Arquivos n√£o encontrados:\n');
    arquivosFaltando.forEach(arquivo => console.error(`   ‚ùå ${arquivo}`));
    process.exit(1);
  }

  const wbIndice = XLSX.readFile(path.join(DATA_DIR, 'indice_pesquisa_abramede.xlsx'));
  dados.indice = XLSX.utils.sheet_to_json(wbIndice.Sheets[wbIndice.SheetNames[0]]);

  const wbPodcasts = XLSX.readFile(path.join(DATA_DIR, 'Podcasts.xlsx'));
  dados.podcasts = XLSX.utils.sheet_to_json(wbPodcasts.Sheets[wbPodcasts.SheetNames[0]]);

  const wbAulas = XLSX.readFile(path.join(DATA_DIR, 'Aulas.xlsx'));
  dados.aulas = XLSX.utils.sheet_to_json(wbAulas.Sheets[wbAulas.SheetNames[0]]);

  dados.paginasLivro = JSON.parse(fs.readFileSync(path.join(DATA_DIR, 'abramede_texto.json'), 'utf-8'));
  dados.embeddingsLivro = JSON.parse(fs.readFileSync(path.join(DATA_DIR, 'embeddings_abramede.json'), 'utf-8'));

  // Extrair sum√°rio (p√°ginas 46-59)
  const paginasSumario = dados.paginasLivro.filter(p => p.pagina >= 46 && p.pagina <= 59);
  dados.sumario = paginasSumario.map(p => `[P√°gina ${p.pagina}]\n${p.texto}`).join('\n\n');
  
  console.log('‚úÖ Dados carregados:', {
    indice: dados.indice.length,
    podcasts: dados.podcasts.length,
    aulas: dados.aulas.length,
    paginasLivro: dados.paginasLivro.length,
    embeddingsLivro: dados.embeddingsLivro.length,
    sumario: dados.sumario.length > 0 ? `${paginasSumario.length} p√°ginas` : '‚ùå n√£o encontrado'
  });
  
  if (dados.aulas[0]) {
    console.log('üìã Primeira aula:', {
      nome: dados.aulas[0].Aula,
      autor: dados.aulas[0].Autor || '‚ùå Coluna Autor n√£o encontrada'
    });
  }
  if (dados.podcasts[0]) {
    console.log('üéôÔ∏è Primeiro podcast:', {
      episodio: dados.podcasts[0].Epis√≥dio,
      autor: dados.podcasts[0].Autor || '‚ùå Coluna Autor n√£o encontrada'
    });
  }
}

function cosineSimilarity(vecA, vecB) {
  let dot = 0;
  let normA = 0;
  let normB = 0;

  for (let i = 0; i < vecA.length; i++) {
    dot += vecA[i] * vecB[i];
    normA += vecA[i] * vecA[i];
    normB += vecB[i] * vecB[i];
  }

  return dot / (Math.sqrt(normA) * Math.sqrt(normB));
}

async function gerarEmbedding(texto) {
  if (!extractor) {
    throw new Error('Modelo de embeddings n√£o carregado');
  }
  
  // Gerar embedding usando Transformers.js
  const output = await extractor(texto, { pooling: 'mean', normalize: true });
  return Array.from(output.data);
}

app.post('/api/chat', async (req, res) => {
  try {
    const { pergunta } = req.body;

    if (!pergunta || pergunta.trim().length === 0) {
      return res.json({ resposta: 'Por favor, fa√ßa uma pergunta.', fontes: [] });
    }

    console.log(`\nüîç Pergunta original: "${pergunta}"`);

    // 1Ô∏è‚É£ GERAR M√öLTIPLAS VARIA√á√ïES da pergunta
    console.log('üß† Gerando varia√ß√µes da pergunta...');
    let variacoes = [pergunta]; // Come√ßa com a original
    
    try {
      const variacoesPrompt = `Voc√™ √© especialista em medicina de emerg√™ncia. Gere 3 VARIA√á√ïES DIFERENTES da pergunta abaixo, usando sin√¥nimos m√©dicos e formas alternativas de perguntar a MESMA coisa.

Pergunta: "${pergunta}"

INSTRU√á√ïES:
- Cada varia√ß√£o deve manter o MESMO significado
- Use sin√¥nimos m√©dicos (RCP = reanima√ß√£o cardiopulmonar, PCR = parada, ETCO2 = capnografia)
- Use termos t√©cnicos alternativos
- Mantenha perguntas completas e coerentes

Retorne EXATAMENTE 3 varia√ß√µes, uma por linha, SEM numera√ß√£o, SEM explica√ß√µes:`;

      const variacoesResponse = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [{ role: 'user', content: variacoesPrompt }],
        temperature: 0.5,
        max_tokens: 300
      });

      const variacoesTexto = variacoesResponse.choices[0].message.content.trim();
      const variacoesGeradas = variacoesTexto
        .split('\n')
        .map(v => v.replace(/^\d+\.\s*/, '').trim())
        .filter(v => v.length > 10);
      
      variacoes = [pergunta, ...variacoesGeradas];
      console.log(`‚úÖ ${variacoes.length} vers√µes geradas (original + varia√ß√µes):`);
      variacoes.forEach((v, i) => console.log(`   ${i + 1}. ${v}`));
      
    } catch (error) {
      console.error('‚ö†Ô∏è  Erro ao gerar varia√ß√µes:', error.message);
      console.log('üìå Continuando apenas com pergunta original');
    }

    // 2Ô∏è‚É£ CONSULTAR SUM√ÅRIO para identificar cap√≠tulos relevantes
    console.log('\nüìö Consultando sum√°rio para identificar cap√≠tulos...');
    let paginasAlvo = []; // P√°ginas dos cap√≠tulos identificados
    
    try {
      const sumarioPrompt = `Voc√™ √© um especialista em medicina de emerg√™ncia. Analise o sum√°rio abaixo e identifique TODOS os cap√≠tulos/se√ß√µes que podem conter informa√ß√µes relevantes para responder a pergunta.

PERGUNTA: "${pergunta}"

SUM√ÅRIO DO LIVRO ABRAMEDE:
${dados.sumario}

INSTRU√á√ïES:
- Identifique TODOS os cap√≠tulos/se√ß√µes relevantes (pode ser mais de um)
- Para cada cap√≠tulo, extraia o intervalo de p√°ginas mencionado no sum√°rio
- Se n√£o houver p√°ginas expl√≠citas, estime baseado na estrutura
- Seja INCLUSIVO: inclua cap√≠tulos que possam ter rela√ß√£o mesmo que indireta

Retorne APENAS uma lista de intervalos de p√°ginas no formato:
[p√°gina_inicial]-[p√°gina_final]
[p√°gina_inicial]-[p√°gina_final]

Exemplo:
125-145
230-250

Se n√£o encontrar nenhum cap√≠tulo relevante, retorne: NENHUM`;

      const sumarioResponse = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [{ role: 'user', content: sumarioPrompt }],
        temperature: 0.3,
        max_tokens: 300
      });

      const resultado = sumarioResponse.choices[0].message.content.trim();
      
      if (resultado.toUpperCase() !== 'NENHUM') {
        // Extrair intervalos de p√°ginas
        const intervalos = resultado.match(/(\d+)-(\d+)/g) || [];
        
        intervalos.forEach(intervalo => {
          const [inicio, fim] = intervalo.split('-').map(Number);
          for (let p = inicio; p <= fim; p++) {
            if (!paginasAlvo.includes(p)) {
              paginasAlvo.push(p);
            }
          }
        });
        
        console.log(`‚úÖ Cap√≠tulos identificados: ${intervalos.length}`);
        console.log(`üìÑ P√°ginas alvo: ${paginasAlvo.length} p√°ginas (${paginasAlvo[0]}-${paginasAlvo[paginasAlvo.length-1]})`);
        intervalos.forEach(int => console.log(`   Cap√≠tulo: p√°ginas ${int}`));
      } else {
        console.log('‚ö†Ô∏è  Nenhum cap√≠tulo espec√≠fico identificado no sum√°rio');
      }
      
    } catch (error) {
      console.error('‚ö†Ô∏è  Erro ao consultar sum√°rio:', error.message);
    }
    
    // Se n√£o encontrou p√°ginas espec√≠ficas, buscar em todo o livro
    if (paginasAlvo.length === 0) {
      console.log('üìå Buscando em todo o livro (sem filtro de cap√≠tulo)');
      paginasAlvo = dados.paginasLivro.map(p => p.pagina);
    }

    // 3Ô∏è‚É£ BUSCAR apenas nas p√°ginas dos cap√≠tulos identificados
    console.log('\nüîé Buscando nos cap√≠tulos identificados...');
    const todasPaginas = new Map(); // pagina -> melhor score
    const aulasRelevantes = new Map(); // id aula -> {aula, score}
    const podcastsRelevantes = new Map(); // id podcast -> {podcast, score}
    
    // Filtrar embeddings apenas das p√°ginas alvo
    const embeddingsFiltrados = dados.embeddingsLivro.filter(item => 
      paginasAlvo.includes(item.pagina)
    );
    
    console.log(`   Buscando em ${embeddingsFiltrados.length} p√°ginas filtradas (de ${dados.embeddingsLivro.length} totais)`);
    
    for (let i = 0; i < variacoes.length; i++) {
      const variacao = variacoes[i];
      console.log(`   Varia√ß√£o ${i + 1}/${variacoes.length}...`);
      
      const embedding = await gerarEmbedding(variacao);
      
      // Buscar apenas nas p√°ginas filtradas
      embeddingsFiltrados.forEach(item => {
        const score = cosineSimilarity(embedding, item.embedding);
        const scoreAtual = todasPaginas.get(item.pagina) || 0;
        
        if (score > scoreAtual) {
          todasPaginas.set(item.pagina, score);
        }
      });
      
      // Buscar aulas relevantes no √≠ndice
      dados.indice.forEach((item, idx) => {
        if (item.Tipo === 'Aula') {
          // Criar texto de busca com todos os campos relevantes
          const textoAula = `${item.Tema || ''} ${item.Descri√ß√£o || ''} ${item.Tags || ''}`.toLowerCase();
          const textoVariacao = variacao.toLowerCase();
          
          // Busca por palavras-chave
          let score = 0;
          const palavrasVariacao = textoVariacao.split(/\s+/).filter(p => p.length > 3);
          palavrasVariacao.forEach(palavra => {
            if (textoAula.includes(palavra)) {
              score += 0.15; // Score por palavra encontrada
            }
          });
          
          if (score > 0) {
            const scoreAtual = aulasRelevantes.get(idx)?.score || 0;
            if (score > scoreAtual) {
              aulasRelevantes.set(idx, { aula: item, score });
            }
          }
        }
      });
      
      // Buscar podcasts relevantes no √≠ndice
      dados.indice.forEach((item, idx) => {
        if (item.Tipo === 'Podcast') {
          const textoPodcast = `${item.Tema || ''} ${item.Descri√ß√£o || ''} ${item.Tags || ''}`.toLowerCase();
          const textoVariacao = variacao.toLowerCase();
          
          let score = 0;
          const palavrasVariacao = textoVariacao.split(/\s+/).filter(p => p.length > 3);
          palavrasVariacao.forEach(palavra => {
            if (textoPodcast.includes(palavra)) {
              score += 0.15;
            }
          });
          
          if (score > 0) {
            const scoreAtual = podcastsRelevantes.get(idx)?.score || 0;
            if (score > scoreAtual) {
              podcastsRelevantes.set(idx, { podcast: item, score });
            }
          }
        }
      });
    }
    
    // Ordenar p√°ginas do livro
    const paginasOrdenadas = Array.from(todasPaginas.entries())
      .map(([pagina, score]) => ({ pagina, score }))
      .sort((a, b) => b.score - a.score)
      .slice(0, 10);

    console.log(`\n‚úÖ Resultados da busca:`);
    console.log(`   üìñ ${paginasOrdenadas.length} p√°ginas encontradas nos cap√≠tulos`);
    console.log(`   üìö ${aulasRelevantes.size} aulas relevantes`);
    console.log(`   üéôÔ∏è  ${podcastsRelevantes.size} podcasts relevantes`);
    
    console.log('\nüìÑ Top 10 p√°ginas dos cap√≠tulos:');
    paginasOrdenadas.forEach(p => {
      console.log(`   P√°gina ${p.pagina}: ${(p.score * 100).toFixed(1)}%`);
    });
    
    if (aulasRelevantes.size > 0) {
      console.log('\nüìö Aulas encontradas:');
      Array.from(aulasRelevantes.values())
        .sort((a, b) => b.score - a.score)
        .slice(0, 5)
        .forEach(({aula, score}) => {
          console.log(`   ${aula.Tema} (${(score * 100).toFixed(1)}%)`);
        });
    }
    
    if (podcastsRelevantes.size > 0) {
      console.log('\nüéôÔ∏è  Podcasts encontrados:');
      Array.from(podcastsRelevantes.values())
        .sort((a, b) => b.score - a.score)
        .slice(0, 5)
        .forEach(({podcast, score}) => {
          console.log(`   ${podcast.Tema} (${(score * 100).toFixed(1)}%)`);
        });
    }

    // 4Ô∏è‚É£ VALIDAR se os cap√≠tulos cont√™m informa√ß√£o relevante
    console.log('\nüîç Validando conte√∫do dos cap√≠tulos com OpenAI...');
    
    // Pegar texto de uma amostra das p√°ginas mais relevantes
    const amostraCapitulos = paginasOrdenadas.slice(0, 5).map(p => {
      const paginaObj = dados.paginasLivro.find(pg => pg.pagina === p.pagina);
      return paginaObj ? `[P√°gina ${p.pagina}] ${paginaObj.texto.slice(0, 800)}` : '';
    }).filter(Boolean).join('\n\n');

    let capitulosTemConteudo = false;
    
    try {
      const validacaoCapitulosPrompt = `Analise se o conte√∫do abaixo dos cap√≠tulos identificados REALMENTE cont√©m informa√ß√µes que podem responder √† pergunta, mesmo que parcialmente.

PERGUNTA: "${pergunta}"

AMOSTRA DO CONTE√öDO DOS CAP√çTULOS:
${amostraCapitulos}

Responda APENAS:
- SIM: se h√° informa√ß√£o espec√≠fica relacionada √† pergunta
- N√ÉO: se os cap√≠tulos n√£o abordam o tema da pergunta

Resposta (SIM ou N√ÉO):`;

      const validacaoCapitulos = await openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [{ role: 'user', content: validacaoCapitulosPrompt }],
        temperature: 0,
        max_tokens: 10
      });

      const resultado = validacaoCapitulos.choices[0].message.content.trim().toUpperCase();
      capitulosTemConteudo = resultado.includes('SIM');
      
      if (capitulosTemConteudo) {
        console.log('‚úÖ Cap√≠tulos cont√™m informa√ß√£o relevante');
      } else {
        console.log('‚ùå Cap√≠tulos n√£o cont√™m informa√ß√£o sobre o tema');
      }
      
    } catch (error) {
      console.error('‚ö†Ô∏è  Erro ao validar cap√≠tulos:', error.message);
      capitulosTemConteudo = true; // Em caso de erro, continua com a busca
    }
    
    if (!capitulosTemConteudo) {
      return res.json({
        resposta: '‚ùå Desculpe, n√£o encontrei informa√ß√µes no livro Abramede que respondam √† sua pergunta. O sum√°rio foi consultado e os cap√≠tulos relacionados n√£o cont√™m o conte√∫do necess√°rio.',
        fontes: { paginas: [], aulas: [], podcasts: [] }
      });
    }

    // 5Ô∏è‚É£ VALIDAR p√°ginas espec√≠ficas
    console.log('\nüîç Validando p√°ginas individuais com OpenAI...');
    const paginasValidadas = [];
    
    for (const candidata of paginasOrdenadas) {
      const paginaObj = dados.paginasLivro.find(p => p.pagina === candidata.pagina);
      if (!paginaObj) continue;
      
      const textoCompleto = paginaObj.texto;
      
      try {
        const validacaoPrompt = `Voc√™ √© um validador de relev√¢ncia. Analise se o texto abaixo REALMENTE cont√©m informa√ß√µes que respondem √† pergunta.

PERGUNTA: "${pergunta}"

TEXTO (P√°gina ${candidata.pagina}):
${textoCompleto.slice(0, 2000)}

Responda APENAS:
- SIM: se o texto cont√©m informa√ß√£o espec√≠fica que responde a pergunta
- N√ÉO: se o texto n√£o responde ou s√≥ menciona termos relacionados sem responder

Resposta (SIM ou N√ÉO):`;

        const validacao = await openai.chat.completions.create({
          model: 'gpt-4o-mini',
          messages: [{ role: 'user', content: validacaoPrompt }],
          temperature: 0,
          max_tokens: 10
        });

        const resultado = validacao.choices[0].message.content.trim().toUpperCase();
        
        if (resultado.includes('SIM')) {
          paginasValidadas.push({
            pagina: candidata.pagina,
            texto: textoCompleto,
            score: candidata.score
          });
          console.log(`   ‚úÖ P√°gina ${candidata.pagina}: VALIDADA`);
          
          // Parar ap√≥s encontrar 5 p√°ginas validadas
          if (paginasValidadas.length >= 5) break;
        } else {
          console.log(`   ‚ùå P√°gina ${candidata.pagina}: rejeitada (n√£o responde)`);
        }
        
      } catch (error) {
        console.error(`   ‚ö†Ô∏è  Erro validando p√°gina ${candidata.pagina}:`, error.message);
      }
    }
    
    console.log(`\n‚úÖ ${paginasValidadas.length} p√°ginas validadas`);
    
    // Se nenhuma p√°gina foi validada, retornar mensagem apropriada
    if (paginasValidadas.length === 0) {
      return res.json({
        resposta: '‚ùå Desculpe, n√£o encontrei informa√ß√µes no livro Abramede que respondam especificamente √† sua pergunta. Por favor, reformule ou fa√ßa uma pergunta diferente.',
        fontes: { paginas: [], aulas: [], podcasts: [] }
      });
    }
    
    // Preparar texto das p√°ginas validadas
    const textoPaginas = paginasValidadas.map(p => {
      return `üìñ P√°gina ${p.pagina} (${(p.score * 100).toFixed(1)}% relev√¢ncia):\n${p.texto.slice(0, 1500)}\n`;
    }).join('\n---\n\n');

    // 6Ô∏è‚É£ PREPARAR materiais complementares
    // Criar √≠ndice apenas com materiais relevantes encontrados
    const aulasEncontradas = Array.from(aulasRelevantes.values())
      .sort((a, b) => b.score - a.score)
      .slice(0, 10) // Top 10 aulas
      .map(({aula}) => aula);
    
    const podcastsEncontrados = Array.from(podcastsRelevantes.values())
      .sort((a, b) => b.score - a.score)
      .slice(0, 10) // Top 10 podcasts
      .map(({podcast}) => podcast);
    
    const indiceDados = {
      aulas: aulasEncontradas.map((a, i) => {
        // Encontrar na lista completa para pegar autor
        const aulaCompleta = dados.aulas.find(ac => 
          ac.Aula === a.Tema || ac.Aula?.includes(a.Tema)
        );
        return {
          id: `A${i + 1}`,
          nome: a.Tema,
          autor: aulaCompleta?.Autor || 'N√£o informado'
        };
      }),
      podcasts: podcastsEncontrados.map((p, i) => {
        // Encontrar na lista completa para pegar autor
        const podcastCompleto = dados.podcasts.find(pc => 
          pc.Epis√≥dio === p.Tema || pc.Tema === p.Tema
        );
        return {
          id: `P${i + 1}`,
          episodio: podcastCompleto?.Epis√≥dio || p.Tema,
          tema: p.Tema,
          autor: podcastCompleto?.Autor || 'N√£o informado'
        };
      })
    };

    // 7Ô∏è‚É£ MONTAR RESPOSTA (apenas com conte√∫do validado)
    let materiaisComplementares = '';
    if (indiceDados.aulas.length > 0 || indiceDados.podcasts.length > 0) {
      materiaisComplementares = '\nMATERIAIS COMPLEMENTARES RELEVANTES:\n';
      if (indiceDados.aulas.length > 0) {
        materiaisComplementares += `AULAS: ${indiceDados.aulas.map(a => `${a.id}. ${a.nome}`).join(', ')}\n`;
      }
      if (indiceDados.podcasts.length > 0) {
        materiaisComplementares += `PODCASTS: ${indiceDados.podcasts.map(p => `${p.id}. ${p.episodio} - ${p.tema}`).join(', ')}`;
      }
    }
    
    const prompt = `Voc√™ √© um assistente educacional especializado em medicina de emerg√™ncia ABRAMEDE.

PERGUNTA: "${pergunta}"

CONTE√öDO VALIDADO DO LIVRO ABRAMEDE:
${textoPaginas}
${materiaisComplementares}

‚ö†Ô∏è REGRAS OBRIGAT√ìRIAS:
1. Use APENAS o conte√∫do do livro acima - NUNCA use conhecimento geral
2. SEMPRE cite as p√°ginas espec√≠ficas (ex: "Conforme p√°gina 45...")
3. Se o conte√∫do n√£o responder completamente, diga "O livro n√£o detalha..."
4. NUNCA invente informa√ß√µes
5. Se houver materiais complementares acima, indique-os quando relevantes usando os IDs (A1, P1, etc)

FORMATO OBRIGAT√ìRIO:
[Resposta baseada no livro, citando p√°ginas espec√≠ficas]

üìñ P√ÅGINAS CITADAS:
- P√°gina [X]: [resumo do que foi usado]
- P√°gina [Y]: [resumo do que foi usado]

üìö MATERIAIS COMPLEMENTARES (se houver materiais relevantes acima):
- A[X] (Aula): [nome]
- P[X] (Podcast): [epis√≥dio] - [tema]`;

    // Gerar resposta
    console.log('\nü§ñ Gerando resposta baseada em conte√∫do validado...');
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.2,
      max_tokens: 800
    });

    let resposta = completion.choices[0].message.content;

    // 8Ô∏è‚É£ ENRIQUECER com autores
    const idsAulas = [...new Set(resposta.match(/A\d+/g) || [])];
    const idsPodcasts = [...new Set(resposta.match(/P\d+/g) || [])];

    if (idsAulas.length > 0 || idsPodcasts.length > 0) {
      console.log('üìù Enriquecendo com autores...');
    }
    
    idsAulas.forEach(id => {
      const num = parseInt(id.substring(1)) - 1;
      const aula = indiceDados.aulas[num];
      if (aula && aula.autor !== 'N√£o informado') {
        console.log(`   ${id}: ${aula.nome} - ${aula.autor}`);
        const pattern = `${id} (Aula): ${aula.nome}`;
        const replacement = `${id} (Aula): ${aula.nome} ministrada por ${aula.autor}`;
        resposta = resposta.replace(pattern, replacement);
      }
    });
    
    idsPodcasts.forEach(id => {
      const num = parseInt(id.substring(1)) - 1;
      const podcast = indiceDados.podcasts[num];
      if (podcast && podcast.autor !== 'N√£o informado') {
        console.log(`   ${id}: ${podcast.episodio} - ${podcast.tema} - ${podcast.autor}`);
        
        const lines = resposta.split('\n').map(line => {
          if (line.includes(`${id} (Podcast)`) && !line.includes(' com ')) {
            if (line.includes(podcast.tema)) {
              return line + ` com ${podcast.autor}`;
            } else if (line.includes(podcast.episodio)) {
              return line.replace(
                podcast.episodio,
                `${podcast.episodio} - ${podcast.tema}`
              ) + ` com ${podcast.autor}`;
            }
          }
          return line;
        });
        resposta = lines.join('\n');
      }
    });

    const fontes = {
      paginas: paginasValidadas.map(p => ({ pagina: p.pagina, score: p.score })),
      aulas: idsAulas.map(id => {
        const num = parseInt(id.substring(1)) - 1;
        return indiceDados.aulas[num];
      }).filter(Boolean),
      podcasts: idsPodcasts.map(id => {
        const num = parseInt(id.substring(1)) - 1;
        return indiceDados.podcasts[num];
      }).filter(Boolean)
    };

    console.log('‚úÖ Resposta gerada com sucesso');
    console.log(`üìö Sum√°rio consultado: cap√≠tulos identificados`);
    console.log(`üìÑ ${fontes.paginas.length} p√°ginas validadas e citadas`);
    console.log(`üìö ${fontes.aulas.length} aulas + ${fontes.podcasts.length} podcasts indicados`);
    if (fontes.aulas.length === 0 && aulasRelevantes.size > 0) {
      console.log('‚ö†Ô∏è  Aulas encontradas mas n√£o inclu√≠das na resposta (GPT n√£o considerou relevante)');
    }
    if (fontes.podcasts.length === 0 && podcastsRelevantes.size > 0) {
      console.log('‚ö†Ô∏è  Podcasts encontrados mas n√£o inclu√≠dos na resposta (GPT n√£o considerou relevante)');
    }
    console.log('');

    res.json({
      resposta,
      fontes,
      tokens: completion.usage.total_tokens
    });

  } catch (error) {
    console.error('‚ùå Erro:', error);
    res.status(500).json({
      erro: 'Erro ao processar pergunta',
      detalhes: error.message
    });
  }
});

app.get('/api/health', (req, res) => {
  res.json({
    status: 'ok',
    modeloCarregado: extractor !== null,
    dados: {
      indice: dados.indice.length,
      podcasts: dados.podcasts.length,
      aulas: dados.aulas.length,
      paginasLivro: dados.paginasLivro.length,
      embeddingsLivro: dados.embeddingsLivro.length,
      sumario: dados.sumario.length > 0
    }
  });
});

async function inicializarModelo() {
  console.log('üîß Carregando modelo de embeddings...');
  console.log('   Modelo: Xenova/all-MiniLM-L6-v2');
  console.log('   (Primeira vez pode demorar ~1 minuto para baixar)\n');
  
  try {
    extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
    console.log('‚úÖ Modelo carregado com sucesso!\n');
    return true;
  } catch (error) {
    console.error('‚ùå Erro ao carregar modelo:', error.message);
    return false;
  }
}

const PORT = process.env.PORT || 3000;

async function iniciar() {
  console.log('üöÄ INICIANDO CHATBOT ABRAMEDE\n');
  console.log('='.repeat(60));
  
  // 1. Carregar dados
  carregarDados();
  
  // 2. Carregar modelo de embeddings
  const modeloOk = await inicializarModelo();
  
  if (!modeloOk) {
    console.error('‚ùå N√£o foi poss√≠vel carregar o modelo de embeddings');
    console.error('   O chatbot n√£o funcionar√° corretamente');
  }
  
  // 3. Iniciar servidor
  app.listen(PORT, () => {
    console.log('='.repeat(60));
    console.log(`‚úÖ Servidor rodando na porta ${PORT}`);
    console.log(`üìö Sum√°rio: ${dados.sumario.length > 0 ? 'Carregado (p√°ginas 46-59)' : '‚ùå N√£o encontrado'}`);
    console.log(`üìä Livro: ${dados.paginasLivro.length} p√°ginas indexadas`);
    console.log(`üìö Materiais: ${dados.aulas.length} aulas, ${dados.podcasts.length} podcasts`);
    console.log(`üîß Modelo: ${modeloOk ? 'Carregado' : '‚ùå Erro'}`);
    console.log('\nüåê Acesse: http://localhost:' + PORT);
    console.log('='.repeat(60) + '\n');
  });
}

iniciar();